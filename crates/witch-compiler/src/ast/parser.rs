//! A parser for our `Token` stream to turn into an `Ast`, which the compiler
//! can generate bytecode from.
use chumsky::extra::Full;
use chumsky::input::SpannedInput;
use chumsky::prelude::*;
use std::collections::HashMap;

use crate::ast::BinaryOp;
use crate::ast::{lexer::Token, Ast, Span, Spanned};
use crate::types::{EnumVariant, Type, TypeDecl};

use super::Value;

/// The type of the input that our parser operates on. The input is the `&[(Token, Span)]` token buffer generated by the
/// lexer, wrapped in a `SpannedInput` which 'splits' it apart into its constituent parts, tokens and spans, for chumsky
/// to understand.
type ParserInput<'tokens, 'src> =
    chumsky::input::SpannedInput<Token<'src>, Span, &'tokens [(Token<'src>, Span)]>;

/// Returns our primary parser, which takes a stream of (Token, Span) tuples
/// and returns a Spanned<Ast> for the compiler to act on.
pub fn parser<'tokens: 'src, 'src: 'tokens>() -> impl Parser<
    'tokens,
    ParserInput<'tokens, 'src>,
    Spanned<Ast>,
    extra::Err<Rich<'tokens, Token<'src>, Span>>,
> + Clone {
    recursive(
        |expr: Recursive<
            dyn chumsky::Parser<
                'src,
                SpannedInput<Token, SimpleSpan, &[(Token, SimpleSpan)]>,
                (Ast, SimpleSpan),
                Full<Rich<Token>, (), ()>,
            >,
        >| {
            // Identifiers (i.e. words that arent keywords, strings, etc)
            let ident = select! { Token::Ident(ident) => ident }
                .map(|s| s.to_string())
                .labelled("identifier");

            // <T, U>
            let typevar_decl = ident
                .separated_by(just(Token::Ctrl(",")))
                .collect::<Vec<String>>()
                .delimited_by(just(Token::Op("<")), just(Token::Op(">")))
                .labelled("typevar declaration");

            // Type assertion
            // Ident, Ident<Wrapped>, Ident, Ident -> Ident
            let type_assertion = recursive(|type_assertion| {
                // Primitive types can easily be mapped from &str -> Type,
                // such as i32 or "myCustomType".
                let primitive = select! { Token::Ident(ident) => ident }
                    .map(Type::from)
                    .boxed();

                // <T>(ArgType, ArgType2) -> ReturnType where T: Interface
                let fn_signature = typevar_decl
                    .clone()
                    .or_not()
                    .then(
                        type_assertion
                            .clone()
                            .separated_by(just(Token::Ctrl(",")))
                            .collect::<Vec<_>>()
                            .delimited_by(just(Token::Ctrl("(")), just(Token::Ctrl(")"))),
                    )
                    .then(
                        just(Token::Op("->"))
                            .ignore_then(type_assertion.clone())
                            .then(
                                just(Token::Where)
                                    .ignore_then(
                                        (ident
                                            .then_ignore(just(Token::Ctrl(":")))
                                            .then(type_assertion.clone()))
                                        .separated_by(just(Token::Ctrl(",")))
                                        .collect::<HashMap<String, Type>>(),
                                    )
                                    .or_not(),
                            ),
                    )
                    .map(|((maybe_generics, args), (returns, maybe_constraints))| {
                        // Set up generics hashmap from declared type vars
                        // Finally, go through constraints to turn generic vars type constraints into other types
                        let mut generics = HashMap::new();
                        if let Some(vars) = maybe_generics {
                            for v in vars.into_iter() {
                                generics.insert(v, Type::Any);
                            }
                        }
                        if let Some(constraints) = maybe_constraints {
                            for (k, v) in constraints.into_iter() {
                                generics.entry(k).and_modify(|e| *e = v);
                            }
                        }

                        Type::Function {
                            args,
                            returns: Box::new(returns),
                            is_variadic: false,
                            generics,
                        }
                    })
                    .boxed()
                    .memoised()
                    .labelled("function signature");

                //
                let inner_types = ident
                    .then(
                        type_assertion
                            .clone()
                            .separated_by(just(Token::Ctrl(",")))
                            .at_least(1)
                            .collect::<Vec<Type>>()
                            .delimited_by(just(Token::Op("<")), just(Token::Op(">"))),
                    )
                    .map(|(i, t)| match &*i.to_lowercase() {
                        "list" => {
                            if t.len() != 1 {
                                panic!("List only supports 1 inner type");
                            }
                            Type::List(Box::new(t[0].clone()))
                        }
                        i => Type::TypeVar {
                            name: i.to_string(),
                            inner_types: t,
                        },
                    });

                let intersection = type_assertion
                    .clone()
                    .separated_by(just(Token::Op("+")))
                    .at_least(1)
                    .collect::<Vec<Type>>()
                    .map(Type::Intersection)
                    .boxed()
                    .memoised();

                return choice((inner_types, primitive, fn_signature, intersection)).boxed();
            })
            .memoised()
            .boxed()
            .labelled("type assertion");

            // let string = select! {
            //     Token::Str(s) => s.strip_prefix('"').unwrap_or(s).strip_suffix('"').unwrap_or(s)
            // };

            // Blocks are expressions but delimited with braces.
            let block = expr
                .clone()
                .delimited_by(just(Token::Ctrl("{")), just(Token::Ctrl("}")))
                .map_with_span(|(mut body, body_span), span| {
                    if !matches!(body, Ast::Statement { .. }) {
                        body = Ast::Return(Box::new((body, body_span)));
                    }

                    (Ast::Block(Box::new((body, body_span))), span)
                })
                .memoised()
                .boxed()
                .labelled("block");

            let fn_ = typevar_decl
                .clone()
                .or_not()
                .then(
                    just(Token::Ctrl("("))
                        .ignore_then(
                            ident
                                .then(
                                    (just(Token::Ctrl(":")).ignore_then(type_assertion.clone()))
                                        .or_not(),
                                )
                                .separated_by(just(Token::Ctrl(",")))
                                .collect::<Vec<_>>(),
                        )
                        .then(
                            (just(Token::Ctrl(","))
                                .or_not()
                                .ignore_then(just(Token::Ctrl(".")))
                                .ignore_then(just(Token::Ctrl(".")))
                                .ignore_then(just(Token::Ctrl(".")))
                                .ignore_then(
                                    ident.then(
                                        (just(Token::Ctrl(":"))
                                            .ignore_then(type_assertion.clone()))
                                        .or_not(),
                                    ),
                                ))
                            .or_not(),
                        )
                        .then_ignore(just(Token::Ctrl(")"))),
                )
                .then(
                    just(Token::Op("->"))
                        .ignore_then(type_assertion.clone().or_not())
                        .then(
                            just(Token::Where)
                                .ignore_then(
                                    (ident
                                        .then_ignore(just(Token::Ctrl(":")))
                                        .then(type_assertion.clone()))
                                    .separated_by(just(Token::Ctrl(",")))
                                    .collect::<HashMap<String, Type>>(),
                                )
                                .or_not(),
                        ),
                )
                .then(block.clone().boxed())
                .map(
                    |(
                        (
                            (maybe_generics, (arg_types_opts, maybe_variadic)),
                            (return_type, maybe_constraints),
                        ),
                        (e, span),
                    )| {
                        let mut is_variadic = false;
                        let mut args = vec![];
                        let mut arg_types = arg_types_opts
                            .into_iter()
                            .map(|(a, maybe_type)| {
                                args.push(a);
                                maybe_type.unwrap_or(Type::Any)
                            })
                            .collect::<Vec<Type>>();

                        if let Some((variadic_arg_name, variadic_arg_type)) = maybe_variadic {
                            is_variadic = true;
                            args.push(variadic_arg_name);
                            if let Some(variadic_arg_type) = variadic_arg_type {
                                arg_types.push(variadic_arg_type);
                            } else {
                                arg_types.push(Type::Any);
                            }
                        }
                        let body = match e.clone() {
                            b @ Ast::Block(..) => Box::new(b),
                            // If its not a block, its likely an inline expression and should just be returned.
                            // We wrap it in a Block to handle the scoping easier during compilation.
                            _ => Box::new(Ast::Block(Box::new((
                                Ast::Return(Box::new((e, span))),
                                span,
                            )))),
                        };

                        // Set up generics hashmap from declared generic vars
                        // Finally, go through constraints to turn generic vars type constraints into other types
                        let mut generics = HashMap::new();
                        if let Some(vars) = maybe_generics {
                            for v in vars.into_iter() {
                                generics.insert(v, Type::Any);
                            }
                        }
                        if let Some(constraints) = maybe_constraints {
                            for (k, v) in constraints.into_iter() {
                                generics.entry(k).and_modify(|e| *e = v);
                            }
                        }

                        Ast::Function {
                            is_variadic,
                            args,
                            body,
                            r#type: Type::Function {
                                args: arg_types,
                                returns: Box::new(return_type.unwrap_or(Type::Unknown)),
                                is_variadic,
                                generics,
                            },
                        }
                    },
                )
                .memoised()
                .labelled("function");

            let inline_expr = recursive(|inline_expr| {
                //
                // Values
                //
                let val = select! {
                    Token::Bool(x) => Ast::Value(Value::Bool(x)),
                    Token::Int(n) => Ast::Value(Value::I32(n)),
                    Token::Float(n) => Ast::Value(Value::F32(n)),
                    Token::Str(s) => Ast::Value(Value::String(s.strip_prefix('"').unwrap_or(s).strip_suffix('"').unwrap_or(s).to_string())),
                    Token::Bytes(s) => {
                        Ast::Value(Value::List(s.into_iter().map(Value::U8).collect()))
                    }
                }
                .labelled("value");

                //
                // References a variable on the stack
                //
                let var = ident.map(Ast::Var).labelled("var");

                //
                // A list of expressions, could be arguments or a vec
                //
                let items = expr
                    .clone()
                    .separated_by(just(Token::Ctrl(",")))
                    .allow_trailing()
                    .collect::<Vec<_>>();

                //
                // A list of properties, used by objects
                // ident: expr, ...
                //
                let properties = ident
                    .then_ignore(just(Token::Ctrl(":")))
                    .then(inline_expr.clone())
                    .separated_by(just(Token::Ctrl(",")))
                    .allow_trailing()
                    .collect::<HashMap<String, Spanned<Ast>>>();

                let fn_ = typevar_decl.clone().or_not().then(just(Token::Ctrl("("))
                    .ignore_then(
                        ident.then((just(Token::Ctrl(":")).ignore_then(type_assertion.clone())).or_not())
                            .separated_by(just(Token::Ctrl(",")))
                            .collect::<Vec<_>>(),
                    )
                    .then(
                        (just(Token::Ctrl(",")).or_not().ignore_then(just(Token::Ctrl("."))).ignore_then(just(Token::Ctrl("."))).ignore_then(just(Token::Ctrl("."))).ignore_then(ident.then((just(Token::Ctrl(":")).ignore_then(type_assertion.clone())).or_not()))).or_not())
                    .then_ignore(just(Token::Ctrl(")"))))
                    .then_ignore(just(Token::Op("->")))
                    .then(choice((
                        type_assertion.clone().or_not().then(just(Token::Where).ignore_then((ident.then_ignore(just(Token::Ctrl(":"))).then(type_assertion.clone())).separated_by(just(Token::Ctrl(","))).collect::<HashMap<String, Type>>()).or_not()).then(block.clone().boxed()), 
                        inline_expr.clone().boxed().map(|e| ((None, None), e))
                    )).boxed())
                    .map(|((maybe_generics, (arg_types_opts, maybe_variadic)), ((return_type, maybe_constraints), (e, span)))| {
                        let mut is_variadic = false;
                        let mut args = vec![];
                        let mut arg_types = arg_types_opts.into_iter().map(|(a, maybe_type)| {
                            args.push(a);
                            maybe_type.unwrap_or(Type::Any)
                        }).collect::<Vec<Type>>();

                        if let Some((variadic_arg_name, variadic_arg_type)) = maybe_variadic {
                            is_variadic = true;
                            args.push(variadic_arg_name);
                            if let Some(variadic_arg_type) = variadic_arg_type {
                                arg_types.push(variadic_arg_type);
                            } else {
                                arg_types.push(Type::Any);
                            }
                        }
                        let body = match e.clone() {
                            b @ Ast::Block(..) => Box::new(b),
                            // If its not a block, its likely an inline expression and should just be returned.
                            // We wrap it in a Block to handle the scoping easier during compilation.
                            _ => Box::new(
                                Ast::Block(Box::new((Ast::Return(Box::new((e, span))), span)))
                            )
                        };
                       // Set up generics hashmap from declared generic vars
                 // For each custom type that matches the generic vars, turn it into a typevariable
                 // Finally, go through constraints to turn generic vars type constraints into other types
                  let mut generics = HashMap::new();
                  if let Some(vars) = maybe_generics {
                    for v in vars.into_iter() {
                        generics.insert(v, Type::Any);
                    }
                  }
                  if let Some(constraints) = maybe_constraints {
                    for (k, v) in constraints.into_iter() {
                        generics.entry(k).and_modify(|e| *e = v);
                    }
                }
                        Ast::Function {
                            is_variadic,
                            args,
                            body,
                            r#type: Type::Function{ args: arg_types, returns: Box::new(return_type.unwrap_or(Type::Unknown)), is_variadic, generics },
                        }
                    }).map_with_span(|expr, span| (expr, span)).memoised().boxed().labelled("function");

                let assignment_expr = ident
                .then((just(Token::Ctrl(":")).ignore_then(type_assertion.clone())).or_not())
                    .then_ignore(just(Token::Op("=")))
                    .then(choice((block.clone(), fn_.clone(), expr.clone())).boxed())
                    .map(|(ident_and_maybe_type, expr)| {
                        match expr.clone() {
                            (Ast::Statement { expr: a, rest: b }, _) => {
                                (ident_and_maybe_type.clone(), Ast::Statement {
                                    expr: Box::new((Ast::Assignment{ ident: ident_and_maybe_type.0, expr: a }, expr.1)),
                                    rest: b,
                            })
                            }
                            _ => (ident_and_maybe_type.clone(), Ast::Assignment { ident: ident_and_maybe_type.0, expr: Box::new(expr)}),
                        }

                    }).memoised();

                let assignment = assignment_expr.clone().map(|(_, assignment)| assignment);

                //
                // A let expression
                //
                let let_ = just(Token::Let)
                    .ignore_then(assignment_expr)
                    .map_with_span(|((ident, maybe_type), expr), span| {
                        let _ty = maybe_type.unwrap_or(Type::Unknown);
                        match expr.clone() {
                        Ast::Statement{ expr: a, rest: b } => {
                            Ast::Statement{ expr: Box::new((Ast::Let { ident, expr: a.clone()}, a.1)), rest: b }
                        }
                        _ => Ast::Let{ ident, expr: Box::new((expr, span))}
                    }});

                //
                // A list of expressions,
                // e.g. [1, "two", 3.0]
                //
                let list = items
                    .clone()
                    .delimited_by(just(Token::Ctrl("[")), just(Token::Ctrl("]")))
                    .map(Ast::List);

                //
                // Structs and anonymous objects
                // e.g. Foo { foo: bar, baz: 5 } or simply { x: 1, y: 2 }
                //
                let object = ident.or_not().then(properties
                    .clone()
                    .delimited_by(just(Token::Ctrl("{")), just(Token::Ctrl("}"))))
                    .map(|(maybe_name, hm)|{
                        Ast::Struct {
                            name: maybe_name,
                            fields: hm
                        }
                    });

                //
                // 'Atoms' are expressions that contain no ambiguity
                //
                let atom = choice((
                    fn_,
                    choice((
                        val.boxed(),
                        list.boxed(),
                        object.boxed(),
                        assignment.boxed(),
                        let_.boxed(),
                        var.boxed()
                    )).map_with_span(|expr, span| (expr, span)),
                    expr
                    .clone()
                    .delimited_by(just(Token::Ctrl("(")), just(Token::Ctrl(")")))))
                    .memoised()
                    .boxed();

                //
                // References a property or entry in an object by dot notation
                // E.g. x.y, obj.prop(), etc.    
                    let entry_dot = inline_expr.clone().memoised().then_ignore(just(Token::Ctrl("."))).foldl(ident.separated_by(just(Token::Ctrl("."))), |(expr, expr_span), key| {
                        match expr.clone() {
                            Ast::Statement { expr: x, rest: Some(y)} => (
                                Ast::Statement {
                                    expr: x,
                                    rest: Some(Box::new((
                                        Ast::Access {
                                            container: y,
                                            key: Box::new(
                                                (Ast::Value(Value::String(key)), expr_span)),
                                        },
                                        expr_span,
                                    ))),
                                },
                                expr_span,
                            ),
                            _ => {
                                (
                                    Ast::Access {
                                        container: Box::new((expr.clone(), expr_span)),
                                        key: Box::new((Ast::Value(Value::String(key)), expr_span))
                                    },
                                    expr_span,
                                )
                            }
                        }
                    });

                //
                // References a property or entry in an object by bracket notation
                // E.g. x.y, obj.prop(), etc.
                //
                let entry_bracket = inline_expr.clone().memoised().foldl(
                    (just(Token::Ctrl("["))
                        .ignore_then(inline_expr.clone())
                        .then_ignore(just(Token::Ctrl("]"))))
                    .repeated(),
                    |a, b| (Ast::Access{ container: Box::new(a.clone()), key: Box::new(b)}, a.1),
                );

                let entry = entry_dot.or(entry_bracket);

                let call = entry.or(atom.clone()).foldl(
                    items.clone()
                        .delimited_by(just(Token::Ctrl("(")), just(Token::Ctrl(")")))
                        .map_with_span(|args, span: Span| (args, span))
                        .repeated(),
                    |f, args| {
                        let span = f.1.start..args.1.end;
                        match f.clone() {
                            (Ast::Statement{ expr: a, rest: Some(b) }, _) => (
                                Ast::Statement{
                                    expr: a,
                                    rest: Some(Box::new((Ast::Call{ expr: b, args: args.0 }, span.clone().into()))),
                                },
                                span.into(),
                            ),
                            _ => (Ast::Call{ expr: Box::new(f), args: args.0 }, span.into()),
                        }
                    },
                )
                .labelled("call");

                // Product ops (multiply and divide) have equal precedence
                let op = just(Token::Op("*"))
                    .to(BinaryOp::Mul)
                    .or(just(Token::Op("/")).to(BinaryOp::Div));
                let product = call.clone().foldl(op.then(call).repeated(), |a, (op, b)| {
                    let span = a.1.start..b.1.end;
                    (Ast::BinaryOperation { a: Box::new(a), op, b: Box::new(b) }, span.into() )
                });

                // Sum ops (add and subtract) have equal precedence
                let op = just(Token::Op("+"))
                    .to(BinaryOp::Add)
                    .or(just(Token::Op("-")).to(BinaryOp::Sub));
                let sum = product
                    .clone()
                    .foldl(op.then(product).repeated(), |a, (op, b)| {
                        let span = a.1.start..b.1.end;
                        (Ast::BinaryOperation { a: Box::new(a), op, b: Box::new(b) }, span.into() )
                    });

                // Comparison ops (equal, not-equal) have equal precedence
                let op = just(Token::Op("==")).to(BinaryOp::Eq)
                    .or(just(Token::Op("!=")).to(BinaryOp::NotEq))
                    .or(just(Token::Op("<")).to(BinaryOp::Lt))
                    .or(just(Token::Op(">")).to(BinaryOp::Gt));     

                sum.clone().foldl(op.then(sum).repeated(), |a, (op, b)| {
                    let span = a.1.start..b.1.end;
                    (Ast::BinaryOperation { a: Box::new(a), op, b: Box::new(b) }, span.into() )
                })
            }).memoised().boxed()
            .labelled("inline_expr");

            let if_ = recursive(|if_| {
                just(Token::If)
                    .ignore_then(expr.clone())
                    .then(block.clone())
                    .then(
                        just(Token::Else)
                            .ignore_then(block.clone().or(if_))
                            .or_not(),
                    )
                    .map_with_span(|((cond, a), b), span: Span| {
                        (
                            Ast::If {
                                predicate: Box::new(cond),
                                then_: Box::new(a),
                                // If an `if` expression has no trailing `else` block, we magic up one that just produces null
                                else_: Box::new(
                                    b.unwrap_or_else(|| (Ast::Value(Value::Void), span)),
                                ),
                            },
                            span,
                        )
                    })
            })
            .boxed()
            .labelled("if_");

            let mod_ = just(Token::Mod)
                .ignore_then(ident)
                .then(block.clone())
                .map_with_span(|(ident, block), span| {
                    (
                        Ast::Mod {
                            name: ident,
                            expr: Box::new(block),
                        },
                        span,
                    )
                });

            // Both blocks and `if` are 'block expressions' and can appear in the place of statements
            let block_expr = block.clone().or(if_);

            let block_chain = block_expr
                .clone()
                .foldl(block_expr.clone().repeated(), |a, b| {
                    let span = a.1.start..b.1.end;
                    (
                        Ast::Statement {
                            expr: Box::new(a),
                            rest: Some(Box::new(b)),
                        },
                        span.into(),
                    )
                });

            let inline_or_blocks =
                choice((inline_expr.clone(), block_chain.clone())).labelled("inline_or_blocks");

            // loop {} just shorthands to while (true) {}
            let loop_ =
                just(Token::Loop)
                    .ignore_then(block.clone())
                    .map_with_span(|block, span| {
                        (
                            Ast::While {
                                predicate: Box::new((Ast::Value(Value::Bool(true)), span)),
                                expr: Box::new(block),
                            },
                            span,
                        )
                    });

            let while_ = just(Token::While)
                .ignore_then(expr.clone())
                .then(block.clone())
                .map_with_span(|(cond, block), span| {
                    (
                        Ast::While {
                            predicate: Box::new(cond),
                            expr: Box::new(block),
                        },
                        span,
                    )
                });

            let loops = loop_.or(while_);

            let break_ = just(Token::Break)
                .ignore_then(just(Token::Ctrl(";")))
                .ignore_then(expr.clone().or_not().boxed())
                .map_with_span(|rest, span| {
                    if let Some((Ast::Statement { expr: a, .. }, _)) = rest {
                        (
                            Ast::Statement {
                                expr: Box::new((Ast::Break, a.1)),
                                rest: None,
                            },
                            a.1,
                        )
                    } else {
                        (Ast::Break, span)
                    }
                })
                .labelled("break");

            let continue_ = just(Token::Continue)
                .ignore_then(just(Token::Ctrl(";")))
                .ignore_then(expr.clone().or_not().boxed())
                .map_with_span(|rest, span| {
                    if let Some((Ast::Statement { expr: a, .. }, _)) = rest {
                        (
                            Ast::Statement {
                                expr: Box::new((Ast::Continue, a.1)),
                                rest: None,
                            },
                            a.1,
                        )
                    } else {
                        (Ast::Continue, span)
                    }
                })
                .labelled("continue");

            /*

            Struct declarations

            type Foo struct {
                field_name: String;
                method_name: (String) -> Int {
                    return 10;
                }
            }

            */
            let struct_declaration = just(Token::Type)
                .ignore_then(ident)
                .then_ignore(just(Token::Struct))
                .then_ignore(just(Token::Ctrl("{")))
                // Fields
                // field_name: Type;
                .then(
                    ident
                        .then_ignore(just(Token::Ctrl(":")))
                        .then(type_assertion.clone())
                        .then_ignore(just(Token::Ctrl(";")))
                        .repeated()
                        .collect::<HashMap<String, Type>>(),
                )
                // Methods
                // method_name: () -> {}
                .then(
                    ident
                        .then_ignore(just(Token::Ctrl(":")))
                        .then(fn_.clone())
                        .repeated()
                        .at_least(0)
                        .collect::<Vec<(String, Ast)>>(),
                )
                .then_ignore(just(Token::Ctrl("}")))
                .map_with_span(|((struct_name, fields), methods), span| {
                    (
                        Ast::Type {
                            name: struct_name,
                            decl: TypeDecl::Struct { fields, methods },
                        },
                        span,
                    )
                });

            /*

            Interface declarations

            type Foo interface {
                method_name: (String) -> Int,
                method_name2: (String) -> Int
            }

            */
            let interface_declaration = just(Token::Type)
                .ignore_then(ident)
                .then_ignore(just(Token::Interface))
                .then_ignore(just(Token::Ctrl("{")))
                // Fields & Methods
                // field_or_method_name: Type,
                .then(
                    ident
                        .then_ignore(just(Token::Ctrl(":")))
                        .then(type_assertion.clone())
                        .separated_by(just(Token::Ctrl(",")))
                        .collect::<HashMap<String, Type>>(),
                )
                .then_ignore(just(Token::Ctrl("}")))
                .map_with_span(|(struct_name, properties), span| {
                    (
                        Ast::Type {
                            name: struct_name,
                            decl: TypeDecl::Interface { properties },
                        },
                        span,
                    )
                });

            /*

            Enum declarations

            type Foo enum {
               One,
               Two(string, int)
            }

            let x = Foo.VariantTwo("foo!", 5);

            */
            let enum_declaration = just(Token::Type)
                .ignore_then(ident)
                .then(typevar_decl.clone().or_not())
                .then(
                    just(Token::Where)
                        .ignore_then(
                            (ident
                                .then_ignore(just(Token::Ctrl(":")))
                                .then(type_assertion.clone()))
                            .separated_by(just(Token::Ctrl(",")))
                            .collect::<HashMap<String, Type>>(),
                        )
                        .or_not(),
                )
                .then_ignore(just(Token::Enum))
                .then_ignore(just(Token::Ctrl("{")))
                // Variants
                .then(
                    ident
                        .then(
                            type_assertion
                                .clone()
                                .separated_by(just(Token::Ctrl(",")))
                                .collect::<Vec<Type>>()
                                .delimited_by(just(Token::Ctrl("(")), just(Token::Ctrl(")")))
                                .or_not(),
                        )
                        .separated_by(just(Token::Ctrl(",")))
                        .collect::<Vec<(String, Option<Vec<Type>>)>>(),
                )
                .then_ignore(just(Token::Ctrl("}")))
                .map_with_span(
                    |(((type_name, maybe_generics), maybe_constraints), variant_data), span| {
                        let mut generics = HashMap::new();
                        if let Some(vars) = maybe_generics {
                            for v in vars.into_iter() {
                                generics.insert(v, Type::Any);
                            }
                        }
                        if let Some(constraints) = maybe_constraints {
                            for (k, v) in constraints.into_iter() {
                                generics.entry(k).and_modify(|e| *e = v);
                            }
                        }
                        let variants = variant_data
                            .into_iter()
                            .enumerate()
                            .map(|(idx, (name, types))| EnumVariant {
                                discriminant: idx as u32,
                                name,
                                types,
                                generics: generics.clone(),
                            })
                            .collect();
                        (
                            Ast::Type {
                                name: type_name,
                                decl: TypeDecl::Enum { variants },
                            },
                            span,
                        )
                    },
                );

            let type_decl = enum_declaration
                .or(interface_declaration)
                .or(struct_declaration);

            let statement = type_decl
                .or(loops)
                .or(mod_)
                .or(inline_expr.clone().then_ignore(just(Token::Ctrl(";"))))
                .then(expr.clone().or_not().boxed())
                .map_with_span(|(a, mut b), _span| {
                    // This allows creating a span that covers the entire Then expression.
                    // b_end is the end of b if it exists, otherwise it is the end of a.
                    let a_start = a.1.start;
                    let b_end = b.as_ref().map(|b| b.1.end).unwrap_or(a.1.end);

                    if let Some((rest, rest_span)) = b.clone() {
                        if !matches!(rest, Ast::Statement { .. }) {
                            b = Some((Ast::Return(Box::new((rest, rest_span))), rest_span));
                        }
                    }

                    (
                        Ast::Statement {
                            expr: Box::new(a),
                            rest: b.map(Box::new),
                        },
                        (a_start..b_end).into(),
                    )
                })
                .boxed()
                .labelled("statement");

            let return_ = just(Token::Return)
                .ignore_then(statement.clone())
                .map(|(stmt, span)| {
                    if let Ast::Statement { expr: a, .. } = stmt {
                        (
                            Ast::Statement {
                                expr: Box::new((Ast::Return(a.clone()), a.1)),
                                rest: None,
                            },
                            a.1,
                        )
                    } else {
                        (stmt, span)
                    }
                })
                .labelled("return");

            choice((
                break_.or(continue_),
                return_,
                block_chain,
                statement,
                inline_or_blocks.clone(),
            ))
            .boxed()
        },
    )
}
